# OpenSpec 并行增量修复计划

## 问题概述
- 活跃变更在归档时应用需求级别的替换。当两个变更触及同一需求时,第二次归档会覆盖第一次并静默删除场景(例如,Windsurf 与 Kilo Code 的斜杠命令更新)。
- 归档工作流(`src/core/archive.ts:191` 和 `src/core/archive.ts:501`)通过用变更增量中包含的内容替换整个需求块来重建主规范。增量格式(`src/core/parsers/requirement-blocks.ts:113`)没有基础版本或场景级操作的概念。
- 工具无法检测变更作者的起始点与实时规范之间的差异,因此并行开发会在没有警告的情况下破坏真实来源。

## 观察到的失败模式
- 变更 A(`add-windsurf-workflows`)在 `Slash Command Configuration` 下添加了 Windsurf 场景。
- 变更 B(`add-kilocode-workflows`)从 Windsurf 之前的规范开始,向同一需求添加 Kilo Code 场景。
- 变更 A 归档后,主规范包含两个场景。
- 当变更 B 归档时,`buildUpdatedSpec` 看到 `Slash Command Configuration` 的 `MODIFIED` 块,并用该变更中发布的四场景变体替换需求。由于该文件从未了解过 Windsurf,因此 Windsurf 场景消失了。
- 没有警告、差异或冲突指示器——归档成功完成,而真实来源规范现在省略了已发布的场景。

## 根本原因
1. **仅替换语义。** `buildUpdatedSpec` 执行需求块的哈希映射替换,无法合并或比较单个场景(`src/core/archive.ts:455`-`src/core/archive.ts:526`)。
2. **缺少基础指纹。** 变更不会持久化它们所基于的需求内容,因此归档步骤无法判断实时规范是否已偏离。
3. **单层粒度。** 增量语言仅理解需求。即使我们引入场景级解析,如果没有相应的合并策略,我们仍然会丢失同级编辑。
4. **缺乏冲突用户体验。** CLI 从不强制贡献者协调并行更新。没有等效于 `git merge`、`git rebase` 或冲突标记的机制。

## 设计目标
- 无论归档顺序如何,都保留每个已批准的场景。
- 当实时规范与作者的基础版本偏离时,检测并阻止推测性归档。
- 提供确定性、可审查的冲突解决流程,该流程反映源代码控制最佳实践。
- 保持编写体验的人性化:增量应保持为人类可编辑的 markdown。
- 支持增量采用,以便现有存储库可以在不破坏活跃工作的情况下向前推进。

## 建议的修复:分层修复

### 阶段 0 – 止血(检测与护栏)
1. **在每个变更旁边持久化需求指纹。**
   - 在搭建或验证变更时,捕获每个 `MODIFIED`/`REMOVED`/`RENAMED` 条目的当前需求主体,并将其写入 `changes/<id>/meta.json`。
   - 存储基础需求内容的稳定哈希值(例如 SHA-256)以及原始文本本身,以便后续合并。
2. **在归档期间验证指纹。**
   - 在 `buildUpdatedSpec` 变更规范之前,从实时规范重新计算需求哈希值。
   - 如果哈希值与存储的基础版本不同,则中止并指示用户进行变基。这使得破坏性路径变得不可能。
3. **在 CLI 输出中显示意图。**
   - 显示哪些需求已过时、何时偏离以及哪个变更最后接触了它们。
4. **记录临时手动缓解措施。**
   - 更新 `openspec/AGENTS.md` 和文档,以便贡献者知道在另一个变更落地时重新运行 `openspec change sync`(见阶段 1)。

_结果:_ 我们在开发更丰富的合并故事的同时立即防止数据丢失。

### 阶段 1 – 添加变基工作流(作者端合并)
1. **引入 `openspec change sync <id>`(或 `rebase`)。**
   - 读取存储的基础快照、当前规范和作者的增量。
   - 对每个需求执行三方合并。最初可以接受对 markdown 行进行简单的 diff3,因为我们已经在需求大小的块上操作。
   - 如果合并是干净的,则使用合并后的文本重写 `MODIFIED` 块并刷新存储的指纹。
   - 发生冲突时,在变更增量中写入冲突标记(类似于 Git),并要求作者在重新运行验证之前手动编辑。
2. **丰富验证器消息。**
   - `openspec validate` 应该标记未解决的冲突标记或指纹不匹配,以便错误在工作流程早期出现。
3. **可选:** 提供一个 `--rewrite-scenarios` 帮助器,用于合并场景的项目符号列表以减少手动编辑噪音。

_结果:_ 贡献者可以在归档之前安全地将其工作与最新规范协调,恢复真正的并行开发。

### 阶段 2 – 增加增量粒度
1. **使用场景级指令扩展增量语言。**
   - 允许在需求标题下嵌套 `## MODIFIED Requirements` + `## ADDED Scenarios` / `## MODIFIED Scenarios` 部分。
   - 由存储在 `meta.json` 中的稳定场景标识符(显式 ID 或生成的哈希值)支持。这使系统能够推理单个场景。
2. **教解析器理解嵌套操作。**
   - 更新 `parseDeltaSpec` 以除了需求块之外还发出场景级操作。
   - 更新 `buildUpdatedSpec`(或其替代品)以合并场景列表,在以确定性方式插入新条目的同时保留顺序。
3. **自动化迁移。**
   - 提供一次性命令,检查每个现有规范,注入场景 ID,并将正在进行的变更增量重写为更丰富的格式。
4. **当两个变更编辑相同的场景主体或描述时,继续依赖阶段 1 变基流程来解决冲突。**

_结果:_ 大多数并发更新变得可交换,大大降低了人工合并的可能性。

### 阶段 3 – 结构化规范图(长期)
1. **定义稳定的需求 ID。**
   - 在规范中嵌入 `Requirement ID: <uuid>` 标记,以便跟踪重命名和移动。
   - 这将启用未来的功能,如跨能力引用和更好的差异可视化。
2. **将规范编辑建模为对 AST 的操作。**
   - 为需求/场景/元数据构建中间表示(IR)。
   - 使用操作转换或类似 CRDT 的技术来保证合并结合性。
3. **直接与 Git 集成。**
   - 提供可选的 `openspec branch` 脚手架,将规范变更与 Git 分支对齐,让团队利用 Git 的冲突编辑器来处理 markdown IR。

_结果:_ OpenSpec 从基于替换的更新升级为具有弹性、保留意图的规范管理平台。

## 迁移与产品影响
- **回填元数据:** 在初始部署期间为所有活跃变更和当前主规范添加哈希值。
- **CLI 用户体验:** 新命令(`change sync`、增强的 `archive`)需要文档、帮助文本和发布说明。
- **文档和 AGENTS 更新:** 强化变基工作流程并向 AI 助手解释冲突解决。
- **测试:** 引入涵盖分歧需求指纹和合并解决逻辑的测试固件。
- **遥测(可选):** 记录指纹不匹配,以便我们可以看到团队在部署后遇到冲突的频率。

## 开放问题/风险
- 当多个变更在不同点插入时,我们应该如何排序场景?(考虑可选的 `position` 元数据或确定性的字母顺序回退。)
- 如果贡献者删除 `meta.json` 文件,优雅的失败模式是什么?(CLI 应按需重新创建指纹。)
- 我们是否需要支持离线作者,他们在归档前无法轻松重新运行同步命令?(紧急情况下的潜在 `--accept-outdated` 逃生舱口。)
- 如何处理已归档的历史变更?我们可能需要一个迁移脚本来追溯嵌入指纹,以便重新验证成功。

## 立即的下一步
1. 在 `openspec change validate` 期间对指纹捕获进行原型设计,并在不匹配时阻止归档。
2. 使用基于行的 diff3 合并和冲突标记发布 `openspec change sync`。
3. 更新贡献者文档和 AI 指令,要求在归档前运行 `sync`。
4. 规划场景级增量扩展和迁移路径作为后续 RFC。
